"""
EyeconBumps Web App - Broadcasting Engine
Handles message sending to Telegram groups with smart rate limiting
"""
import asyncio
import random
import re
import os
from datetime import datetime, timedelta
from typing import Optional, List, Dict, Any, Callable
from telethon import TelegramClient
from telethon.sessions import StringSession
from telethon.tl.functions.channels import GetForumTopicsRequest
from telethon.tl.functions.messages import SendMessageRequest
from telethon.tl.types import (
    ForumTopic, InputPeerChannel,
    MessageEntityBold, MessageEntityItalic, MessageEntityCode,
    MessageEntityStrike, MessageEntityUnderline, MessageEntityUrl,
    MessageEntityTextUrl, MessageEntityMention, MessageEntityHashtag,
    MessageEntityCustomEmoji, MessageEntityPre, MessageEntitySpoiler
)
from telethon.errors import (
    FloodWaitError, 
    ChatWriteForbiddenError,
    UserDeactivatedError,
    AuthKeyUnregisteredError,
    ChannelPrivateError,
    SlowModeWaitError,
    UserBannedInChannelError,
    ChatAdminRequiredError,
    MessageTooLongError,
    PeerIdInvalidError,
    RPCError
)
from log_service import log_service



def normalize_topic_name(name: str) -> str:
    """
    Normalize topic name for robust matching.
    Removes emojis, special chars, and converts to lowercase.
    """
    if not name:
        return ""
    # Remove emojis and special chars, keep alphanumeric and spaces
    clean = re.sub(r'[^\w\s]', '', name).lower().strip()
    return clean

def get_target_topic_id(topics: List, target_topic: str) -> Optional[int]:
    """
    Find the best matching topic ID for a target topic name using robust matching.
    """
    if not target_topic:
        return None
        
    target_clean = normalize_topic_name(target_topic)
    
    # Map common aliases to canonical names
    aliases = {
        'instagram': ['ig', 'insta', 'instagram'],
        'whatsapp': ['wa', 'wp', 'whatsapp', 'whats app'],
        'telegram': ['tg', 'tele', 'telegram'],
        'snapchat': ['sc', 'snap', 'snapchat'],
        'facebook': ['fb', 'facebook', 'meta'],
        'twitter/x': ['x', 'twitter', 'tw', 'twitterx'],
        'youtube': ['yt', 'youtube'],
        'discord': ['dc', 'discord'],
        'tiktok': ['tt', 'tiktok', 'tik tok'],
        'other': ['other', 'others', 'general', 'chat', 'discussion']
    }
    
    # 1. Exact match (case-insensitive)
    for t in topics:
        if t.title.lower() == target_topic.lower():
            return t.id
            
    # 2. Normalized match
    for t in topics:
        if normalize_topic_name(t.title) == target_clean:
            return t.id
            
    # 3. Alias match
    # Find which canonical category the target belongs to
    target_canonical = None
    for canonical, variations in aliases.items():
        if target_clean in variations or target_topic.lower() in variations:
            target_canonical = canonical
            break
            
    if target_canonical:
        for t in topics:
            t_clean = normalize_topic_name(t.title)
            # Check if topic title matches any alias of the target category
            if t_clean in aliases[target_canonical]:
                return t.id
                
    return None

def convert_entities_to_telethon(json_entities: list) -> list:
    """
    Convert python-telegram-bot style JSON entities to Telethon MessageEntity objects.
    This enables premium emojis and text formatting in broadcasts.
    """
    if not json_entities:
        return None
    
    telethon_entities = []
    entity_map = {
        'bold': MessageEntityBold,
        'italic': MessageEntityItalic,
        'code': MessageEntityCode,
        'strikethrough': MessageEntityStrike,
        'underline': MessageEntityUnderline,
        'url': MessageEntityUrl,
        'text_link': MessageEntityTextUrl,
        'mention': MessageEntityMention,
        'hashtag': MessageEntityHashtag,
        'custom_emoji': MessageEntityCustomEmoji,
        'pre': MessageEntityPre,
        'spoiler': MessageEntitySpoiler,
    }
    
    for entity in json_entities:
        entity_type = entity.get('type', '')
        offset = entity.get('offset', 0)
        length = entity.get('length', 0)
        
        if entity_type in entity_map:
            try:
                if entity_type == 'text_link':
                    telethon_entities.append(
                        MessageEntityTextUrl(offset=offset, length=length, url=entity.get('url', ''))
                    )
                elif entity_type == 'custom_emoji':
                    # Premium emoji - get document_id
                    document_id = entity.get('custom_emoji_id')
                    if document_id:
                        telethon_entities.append(
                            MessageEntityCustomEmoji(offset=offset, length=length, document_id=int(document_id))
                        )
                elif entity_type == 'pre':
                    telethon_entities.append(
                        MessageEntityPre(offset=offset, length=length, language=entity.get('language', ''))
                    )
                else:
                    telethon_entities.append(
                        entity_map[entity_type](offset=offset, length=length)
                    )
            except Exception as e:
                print(f"[ENTITIES] Error converting entity {entity_type}: {e}")
    
    return telethon_entities if telethon_entities else None


class BroadcastResult:
    """Result of a single broadcast attempt."""
    def __init__(self, group: str, status: str, error: str = None, message_id: int = None, peer_id: int = None):
        self.group = group
        self.status = status  # 'sent', 'failed', 'skipped', 'flood_wait'
        self.error = error
        self.message_id = message_id
        self.peer_id = peer_id
        self.timestamp = datetime.now()


class AccountWorker:
    """
    Independent worker for a single account in parallel broadcasting.
    Each account manages its own groups, delays, and status.
    """
    
    def __init__(self, account: Dict[str, Any], api_id: int, api_hash: str):
        self.account = account
        self.account_id = account['id']
        self.phone = account.get('phone_number', 'Unknown')
        self.session_string = account.get('session_string')
        self.api_id = api_id
        self.api_hash = api_hash
        
        # Status tracking
        self.status = "idle"  # idle, running, flood_wait, limited, error
        self.flood_wait_until = None
        self.error_count = 0
        self.success_count = 0
        self.consecutive_errors = 0
        
        # Delay management - fixed 60 second delay
        self.base_delay = 60
        self.current_delay = 60
        self.min_delay = 60
        self.max_delay = 60
        
        # Groups to process
        self.groups = []
        self.current_group_index = 0
        self.current_group_name = None
        
        # Results
        self.sent = 0
        self.failed = 0
        self.recent_logs = []
    
    def get_status_display(self) -> str:
        """Get human-readable status."""
        if self.status == "flood_wait" and self.flood_wait_until:
            remaining = (self.flood_wait_until - datetime.now()).total_seconds()
            if remaining > 0:
                return f"flood_wait ({int(remaining)}s)"
        return self.status
    
    def calculate_delay(self, success: bool, flood_wait: int = None) -> float:
        """Calculate next delay - fixed 60 seconds like adbot."""
        if flood_wait:
            # FloodWait: wait exactly the required time (no extra buffer)
            self.flood_wait_until = datetime.now() + timedelta(seconds=flood_wait)
            self.status = "flood_wait"
            return flood_wait
        
        # Reset status on success
        if success:
            self.consecutive_errors = 0
            self.status = "running"
        
        # Fixed 60 second delay like adbot
        return 60
    
    def add_log(self, group: str, status: str, error: str = None):
        """Add to recent logs."""
        self.recent_logs.append({
            "group": group[:40] if group else "Unknown",
            "status": status,
            "error": error[:30] if error else None,
            "time": datetime.now().strftime("%H:%M:%S"),
            "account": self.phone  # Add account phone for display
        })
        if len(self.recent_logs) > 10:
            self.recent_logs.pop(0)



class Broadcaster:
    """
    Core broadcasting engine for sending messages to Telegram groups.
    
    Features:
    - Smart rate limiting with adaptive delays
    - Forum topic detection
    - Multi-account support with rotation
    - Auto-recovery from FloodWait
    - Detailed logging and analytics
    """
    
    API_ID = int(os.getenv("TELEGRAM_API_ID", "21219293"))
    API_HASH = os.getenv("TELEGRAM_API_HASH", "cff5d321b676104840cf282a742381e0")
    
    def __init__(self, db):
        self.db = db
        self.running_campaigns = {}  # campaign_id -> asyncio.Task
        self.stop_flags = {}  # campaign_id -> bool
        self.removed_accounts = {}  # campaign_id -> set of account_ids to remove
        self.campaign_progress = {}  # campaign_id -> { sent, failed, total, current_group, recent_logs, status }
    
    def remove_account(self, campaign_id: int, account_id: int) -> bool:
        """Remove an account from a running campaign without stopping others."""
        if campaign_id not in self.removed_accounts:
            self.removed_accounts[campaign_id] = set()
        self.removed_accounts[campaign_id].add(account_id)
        print(f"[BROADCASTER] Account {account_id} marked for removal from campaign {campaign_id}")
        return True
    
    def is_account_removed(self, campaign_id: int, account_id: int) -> bool:
        """Check if an account has been removed from a campaign."""
        return account_id in self.removed_accounts.get(campaign_id, set())
    
    def get_progress(self, campaign_id: int) -> Dict[str, Any]:
        """Get live progress for a campaign."""
        return self.campaign_progress.get(campaign_id, {
            "sent": 0,
            "failed": 0,
            "total": 0,
            "current_group": None,
            "recent_logs": [],
            "status": "idle"
        })
    
    
    async def check_spambot_restriction(self, client, account_id):
        """Check @SpamBot for account restrictions and update DB."""
        try:
            from telethon.tl.functions.messages import GetHistoryRequest
            from datetime import timedelta
            import asyncio
            
            # Start chat with @SpamBot
            spambot = await client.get_input_entity('SpamBot')
            await client.send_message(spambot, '/start')
            await asyncio.sleep(2) # Wait for reply
            
            # Fetch last 5 messages from @SpamBot to avoid greeting race condition
            history = await client(GetHistoryRequest(
                peer=spambot,
                limit=5,
                offset_date=None,
                offset_id=0,
                max_id=0,
                min_id=0,
                add_offset=0,
                hash=0
            ))
            
            if not history.messages:
                return None
                
            # Check all recent messages for the status
            combined_text = " ".join([m.message for m in history.messages if m.message]).lower()
            
            good_patterns = ["no limits", "good news", "your account is free", "not limited", "no violations"]
            if any(p in combined_text for p in good_patterns):
                return None
                
            # Try to parse expiry date (Check each message for the date pattern)
            import dateparser
            for m in history.messages:
                if not m.message: continue
                # Pattern: "limited until 14 Feb 2026, 15:30 UTC"
                match = re.search(r'until (.*?) UTC', m.message)
                if match:
                    try:
                        expiry = dateparser.parse(match.group(1))
                        if expiry: return expiry
                    except: pass
            
            if "limited" in combined_text or "iâ€™m afraid" in combined_text:
                # detected limit but no date found
                return datetime.now() + timedelta(days=1)
                
            return None
        except Exception as e:
            print(f"[SPAMBOT] Error checking restriction for account {account_id}: {e}")
            return None

    async def get_all_dialogs(self, session_string: str, client: TelegramClient = None) -> List[Dict[str, Any]]:
        """
        Get all groups/channels/supergroups from an account.
        """
        if not session_string: return []
        local_client = False
        try:
            if not client:
                from telethon import TelegramClient
                from telethon.sessions import StringSession
                client = TelegramClient(StringSession(session_string), self.API_ID, self.API_HASH)
                await client.connect()
                local_client = True
            if not await client.is_user_authorized(): return []
            dialogs = []
            async for dialog in client.iter_dialogs():
                if dialog.is_group or dialog.is_channel:
                    entity = dialog.entity
                    dialogs.append({
                        "id": dialog.id,
                        "name": dialog.name or str(dialog.id),
                        "username": getattr(entity, 'username', None),
                        "is_channel": dialog.is_channel,
                        "is_group": dialog.is_group,
                        "is_forum": getattr(entity, 'forum', False),
                        "unread_count": dialog.unread_count
                    })
            return dialogs
        except Exception as e:
            print(f"[GET_DIALOGS] Error: {e}")
            return []
        finally:
            if local_client and client:
                try: await client.disconnect()
                except: pass
    async def forward_to_group(
        self,
        client: TelegramClient,
        group,  # Can be entity, id, or username
        forward_from_chat: int,
        message_id: int,
        from_username: str = None,  # Add username for fallback resolution
        target_topic: str = None
    ) -> BroadcastResult:
        """
        Forward a message to a group (matches original adbot implementation).
        """
        import random
        from telethon.tl.functions.messages import ForwardMessagesRequest
        
        try:
            # Get the target entity
            try:
                if isinstance(group, dict):
                    entity = await client.get_entity(group.get('id') or group.get('username'))
                    group_id = group.get('id')
                else:
                    entity = await client.get_entity(group)
                    group_id = entity.id
            except Exception as e:
                return BroadcastResult(str(group), 'failed', f'Cannot access target: {str(e)[:50]}')
            
            # PRE-CHECK: Detect slow mode BEFORE attempting to forward
            try:
                from telethon.tl.functions.channels import GetFullChannelRequest
                full_channel = await client(GetFullChannelRequest(entity))
                slowmode_seconds = getattr(full_channel.full_chat, 'slowmode_seconds', 0) or 0
                slowmode_next_send = getattr(full_channel.full_chat, 'slowmode_next_send_date', None)
                
                if slowmode_seconds > 0:
                    import time
                    current_time = int(time.time())
                    
                    # Check if we need to wait before sending
                    if slowmode_next_send:
                        wait_time = slowmode_next_send - current_time
                        if wait_time > 0:
                            print(f"[FORWARD] Slow mode: must wait {wait_time}s for {group_id}")
                            return BroadcastResult(str(group), 'failed', f'Slow mode: wait {wait_time}s')
                    
                    print(f"[FORWARD] Slow mode enabled ({slowmode_seconds}s) for {group_id}, attempting forward...")
            except Exception as e:
                # If we can't check slow mode, continue anyway
                print(f"[FORWARD] Could not pre-check slow mode: {e}")
            
            # Resolve the source entity
            source_entity = None
            
            # PRIORITIZE USERNAME if available - checks cache or fetches fresh
            if from_username:
                try:
                    print(f"[FORWARD] Resolving source via username: {from_username}")
                    source_entity = await client.get_entity(from_username)
                    from_chat = source_entity # Use the actual entity object for forwarding!
                    print(f"[FORWARD] Resolved source: {source_entity.id}")
                except Exception as e:
                    print(f"[FORWARD] Username resolution failed: {e}")

            # Fallback to ID resolution if username failed or wasn't provided
            if not source_entity:
                try:
                    # Ensure from_chat is an integer if it looks like one
                    if isinstance(from_chat, str) and (from_chat.startswith('-100') or from_chat.lstrip('-').isdigit()):
                        from_chat = int(from_chat)
                    
                    # Try to resolve but don't fail if we can't - forward_messages might still work
                    try:
                        source_entity = await client.get_entity(from_chat)
                    except:
                        # Try getting messages to seed the cache
                        try:
                            await client.get_messages(from_chat, limit=1)
                            source_entity = await client.get_entity(from_chat)
                        except:
                            print(f"[FORWARD] Could not verify source {from_chat}, attempting forward anyway...")
                except Exception as e:
                    print(f"[FORWARD] Source check warning: {e}")
            
            # Check if it's a forum
            is_forum = getattr(entity, 'forum', False)
            topic_id = None
            
            if is_forum:
                try:
                    topics = await client(GetForumTopicsRequest(
                        channel=entity,
                        offset_date=None,
                        offset_id=0,
                        offset_topic=0,
                        limit=100
                    ))
                    
                    # FALLBACK CHAIN: Target -> Other -> General -> First Available
                    potential_topics = []
                    for topic in topics.topics:
                        if isinstance(topic, ForumTopic):
                            if not getattr(topic, 'closed', False):
                                potential_topics.append(topic)
                    
                    if not potential_topics:
                        return BroadcastResult(str(group), 'failed', 'All forum topics closed')

                    # 1. Try specific target
                    if target_topic:
                        for t in potential_topics:
                            if t.title.lower() == target_topic.lower():
                                topic_id = t.id
                                break
                    
                    # 2. Try "Other"
                    if not topic_id:
                        for t in potential_topics:
                            if t.title.lower() == 'other':
                                topic_id = t.id
                                break
                    
                    # 3. Try "General" or ID 1
                    if not topic_id:
                        for t in potential_topics:
                            if t.title.lower() == 'general' or t.id == 1:
                                topic_id = t.id
                                break
                    
                    # 4. Try first available
                    if not topic_id:
                        topic_id = potential_topics[0].id
                        
                except Exception as e:
                    print(f"[FORWARD] Could not get topics: {e}")
                    topic_id = 1  # Fallback
            
            # Forward the message - match original adbot exactly
            sent_msg = None
            try:
                if topic_id:
                    # For forums: use ForwardMessagesRequest with top_msg_id (same as original adbot)
                    result = await client(ForwardMessagesRequest(
                        from_peer=from_chat,
                        id=[message_id],  # Must be a list
                        to_peer=entity,
                        top_msg_id=topic_id,
                        random_id=[random.randint(0, 2**63 - 1)]
                    ))
                    # Get message from result
                    if hasattr(result, 'updates') and result.updates:
                        for update in result.updates:
                            if hasattr(update, 'message') and hasattr(update.message, 'id'):
                                sent_msg = update.message
                                break
                    print(f"[FORWARD] Forum: forwarded to {entity.id} topic {topic_id}")
                else:
                    # For regular groups: use simple forward_messages (same as original adbot)
                    sent_msg = await client.forward_messages(entity, message_id, from_chat)
                    if isinstance(sent_msg, list):
                        sent_msg = sent_msg[0] if sent_msg else None
                    print(f"[FORWARD] Regular: forwarded to {entity.id}")
            except Exception as fe:
                print(f"[FORWARD] Forward failed, attempting COPY fallback: {fe}")
                # FALLBACK: Copy text and send if forward fails (Resilience)
                try:
                    # Fetch message content
                    msg = await client.get_messages(from_chat, ids=message_id)
                    if msg:
                        text = msg.text
                        entities = msg.entities
                        if topic_id:
                            sent_msg = await client.send_message(
                                entity, text, formatting_entities=entities, reply_to=topic_id
                            )
                        else:
                            sent_msg = await client.send_message(
                                entity, text, formatting_entities=entities
                            )
                        print(f"[FORWARD] COPY fallback successful")
                    else:
                        raise fe # Re-raise if we can't even get the message
                except Exception as ce:
                    print(f"[FORWARD] COPY fallback failed: {ce}")
                    raise fe # Raise original error
            
            group_name = group.get('name', str(group)) if isinstance(group, dict) else str(group)
            msg_id = sent_msg.id if sent_msg else None
            return BroadcastResult(group_name, 'sent', message_id=msg_id, peer_id=entity.id)
            
        except FloodWaitError as e:
            return BroadcastResult(str(group), 'flood_wait', f'Wait {e.seconds}s')
        except SlowModeWaitError as e:
            return BroadcastResult(str(group), 'failed', f'Slow mode: {e.seconds}s')
        except ChatWriteForbiddenError:
            return BroadcastResult(str(group), 'failed', 'Write forbidden')
        except UserBannedInChannelError:
            return BroadcastResult(str(group), 'failed', 'Banned')
        except Exception as e:
            print(f"[FORWARD] Error: {e}")
            return BroadcastResult(str(group), 'failed', str(e)[:80])
    
    async def send_to_group(
        self, 
        client: TelegramClient, 
        group, 
        message: str,
        media_file_id: str = None,
        message_type: str = "send",  # "send" or "forward"
        forward_from_chat: int = None,
        forward_message_id: int = None,
        forward_from_username: str = None,  # For public channels
        formatting_entities: list = None,  # Telethon entities for premium emoji/formatting
        target_topic: str = None
    ) -> BroadcastResult:
        """
        Send or forward a message to a single group.
        Handles forum detection and various error cases.
        If formatting_entities provided, uses them for premium emojis/formatting.
        """
        # Debug: Log forward mode check
        print(f"[SEND_TO_GROUP] message_type={message_type}, forward_from_chat={forward_from_chat}, forward_message_id={forward_message_id}, username={forward_from_username}")
        
        # Resolve forward_from_username to channel entity if needed
        from_entity = None
        if message_type == "forward" and forward_message_id and not forward_from_chat and forward_from_username:
            try:
                from_entity = await client.get_entity(forward_from_username)
                # For channels/supergroups, format the ID properly with -100 prefix (same as original adbot)
                if hasattr(from_entity, 'broadcast') or hasattr(from_entity, 'megagroup'):
                    # It's a channel or supergroup - use -100 prefix
                    forward_from_chat = int(f"-100{from_entity.id}")
                else:
                    forward_from_chat = from_entity.id
                print(f"[SEND_TO_GROUP] Resolved username '{forward_from_username}' to chat ID {forward_from_chat}")
            except Exception as e:
                print(f"[SEND_TO_GROUP] Failed to resolve username '{forward_from_username}': {e}")
                return BroadcastResult(str(group), 'failed', f'Cannot resolve forward source: {str(e)[:50]}')
        
        # If forward mode
        if message_type == "forward" and forward_from_chat and forward_message_id:
            print(f"[SEND_TO_GROUP] >>> Using FORWARD mode! from_chat={forward_from_chat}, msg_id={forward_message_id}")
            return await self.forward_to_group(
                client, 
                group, 
                forward_from_chat, 
                forward_message_id, 
                from_username=forward_from_username,
                target_topic=target_topic
            )
        else:
            print(f"[SEND_TO_GROUP] >>> Using SEND mode")
        
        try:
            # Get the entity
            try:
                if isinstance(group, dict):
                    entity = await client.get_entity(group.get('id') or group.get('username'))
                    group_name = group.get('name', str(group.get('id')))
                else:
                    entity = await client.get_entity(group)
                    group_name = str(group)
            except PeerIdInvalidError:
                return BroadcastResult(str(group), 'failed', 'Invalid group')
            except ChannelPrivateError:
                return BroadcastResult(str(group), 'failed', 'Private channel')
            except Exception as e:
                return BroadcastResult(str(group), 'failed', f'Cannot access: {str(e)[:50]}')
            # BAN CHECK: Skip if account is banned from this group
            account_id = getattr(client, "_account_id", None)
            if account_id:
                group_id_str = str(entity.id) if hasattr(entity, "id") else str(group)
                if db.is_group_banned(account_id, group_id_str):
                    print(f"[BROADCASTER] Skipping {group_name} - account {account_id} is banned")
                    return BroadcastResult(group_name, "skipped", "Account banned from group")

            
            # PRE-FILTER: Check if we have permission to send messages
            try:
                # Check if messages are restricted for regular users
                default_banned = getattr(entity, 'default_banned_rights', None)
                if default_banned and getattr(default_banned, 'send_messages', False):
                    # Check if we have admin rights that override
                    admin_rights = getattr(entity, 'admin_rights', None)
                    if not admin_rights:
                        return BroadcastResult(group_name, 'skipped', 'No posting permission')
                
                # Check if we're explicitly banned from sending
                banned_rights = getattr(entity, 'banned_rights', None)
                if banned_rights and getattr(banned_rights, 'send_messages', False):
                    return BroadcastResult(group_name, 'skipped', 'Banned from posting')
            except Exception as perm_err:
                # If permission check fails, continue and try to send anyway
                print(f"[BROADCASTER] Permission check failed for {group_name}: {perm_err}")
            
            # PRE-FILTER: Check for slow mode
            slowmode_seconds = getattr(entity, 'slowmode_seconds', 0)
            if slowmode_seconds and slowmode_seconds > 0:
                return BroadcastResult(group_name, 'skipped', f'Slow mode: {slowmode_seconds}s')
            
            # Check if it's a forum
            is_forum = getattr(entity, 'forum', False)
            
            if is_forum:
                # FORUM: Send to ALL topics
                results = []
                try:
                    topics = await client(GetForumTopicsRequest(
                        channel=entity,
                        offset_date=None,
                        offset_id=0,
                        offset_topic=0,
                        limit=100  # Get more topics
                    ))
                    
                    # FALLBACK CHAIN: Target -> Other -> General -> First Available
                    potential_topics = []
                    for topic in topics.topics:
                        if isinstance(topic, ForumTopic):
                            if not getattr(topic, 'closed', False):
                                potential_topics.append(topic)
                    
                    if not potential_topics:
                        return BroadcastResult(group_name, 'failed', 'All forum topics closed')

                    # 1. Try specific target with robust matching
                    target_topic_id = get_target_topic_id([t for t in topics.topics if isinstance(t, ForumTopic)], target_topic)
                    
                    # 2. Try "Other" or "General" if target not found
                    if not target_topic_id:
                        target_topic_id = get_target_topic_id([t for t in topics.topics if isinstance(t, ForumTopic)], "Other")
                    
                    if not target_topic_id:
                        # Try finding a topic with ID 1 (General usually)
                        for t in topics.topics:
                            if isinstance(t, ForumTopic) and t.id == 1:
                                target_topic_id = 1
                                break
                    
                    # 3. Fallback to first available
                    if not target_topic_id and potential_topics:
                        target_topic_id = potential_topics[0].id
                        
                    topic_id = target_topic_id
                    # Send to the chosen topic (Legacy note: User said "Send to ALL topics" before, 
                    # but now wants robust logic for choosing a target)
                    topic = next((t for t in potential_topics if t.id == target_topic_id), potential_topics[0])
                    topic_name = f"{group_name} > {topic.title}"
                    
                    try:
                        if media_file_id:
                            try:
                                await client.send_file(
                                    entity,
                                    media_file_id,
                                    caption=message,
                                    reply_to=topic.id,
                                    formatting_entities=formatting_entities if formatting_entities else None,
                                    parse_mode=None if formatting_entities else 'html'
                                )
                            except Exception as me:
                                print(f"[BROADCASTER] Media send failed, copy fallback: {me}")
                                await client.send_message(
                                    entity,
                                    message,
                                    reply_to=topic.id,
                                    formatting_entities=formatting_entities if formatting_entities else None,
                                    parse_mode=None if formatting_entities else 'html'
                                )
                        else:
                            await client.send_message(
                                entity,
                                message,
                                reply_to=topic.id,
                                formatting_entities=formatting_entities if formatting_entities else None,
                                parse_mode=None if formatting_entities else 'html'
                            )
                        return BroadcastResult(topic_name, 'sent')
                    except Exception as te:
                        print(f"[BROADCASTER] Topic send error: {te}")
                        return BroadcastResult(topic_name, 'failed', str(te)[:50])
                    
                except Exception as e:
                    return BroadcastResult(group_name, 'failed', f'Forum error: {str(e)[:50]}')
            else:
                # Regular group/channel - send normally
                if media_file_id:
                    sent_msg = await client.send_file(
                        entity,
                        media_file_id,
                        caption=message,
                        formatting_entities=formatting_entities if formatting_entities else None,
                        parse_mode=None if formatting_entities else 'html'
                    )
                else:
                    sent_msg = await client.send_message(
                        entity,
                        message,
                        formatting_entities=formatting_entities if formatting_entities else None,
                        parse_mode=None if formatting_entities else 'html'
                    )
                
                return BroadcastResult(group_name, 'sent', message_id=sent_msg.id, peer_id=entity.id)
            
        except FloodWaitError as e:
            return BroadcastResult(str(group), 'flood_wait', f'Wait {e.seconds}s')
        except SlowModeWaitError as e:
            # Slow mode - mark as skipped so it doesn't count as failed
            return BroadcastResult(str(group), 'skipped', f'Slow mode: {e.seconds}s')
        except (ChatWriteForbiddenError, UserBannedInChannelError) as e:
            # Record ban in database
            account_id = getattr(client, "_account_id", None)
            if account_id:
                group_id_str = str(entity.id) if hasattr(entity, "id") else str(group)
                db.add_group_ban(account_id, group_id_str, group_name, str(e))
                print(f"[BROADCASTER] Recorded ban: account {account_id} from {group_name}")
            
            try:
                from telethon.tl.functions.channels import LeaveChannelRequest, JoinChannelRequest
                
                # Step 1: Leave the group
                await client(LeaveChannelRequest(entity))
                print(f"[BROADCASTER] Left banned group: {group}, attempting rejoin...")
                
                # Step 2: Wait a moment
                await asyncio.sleep(2)
                
                # Step 3: Rejoin the group
                await client(JoinChannelRequest(entity))
                print(f"[BROADCASTER] Rejoined group: {group}, retrying message...")
                
                # Step 4: Wait and retry sending
                await asyncio.sleep(1)
                
                if media_file_id:
                    sent_msg = await client.send_file(
                        entity,
                        media_file_id,
                        caption=message,
                        formatting_entities=formatting_entities if formatting_entities else None,
                        parse_mode=None if formatting_entities else 'html'
                    )
                else:
                    sent_msg = await client.send_message(
                        entity,
                        message,
                        formatting_entities=formatting_entities if formatting_entities else None,
                        parse_mode=None if formatting_entities else 'html'
                    )
                
                print(f"[BROADCASTER] Retry successful after rejoin: {group}")
                return BroadcastResult(str(group), 'sent', message_id=sent_msg.id, peer_id=entity.id)
                
            except Exception as rejoin_err:
                # Even if send failed, the group is still joined - mark as such
                print(f"[BROADCASTER] Send after rejoin failed: {rejoin_err}")
                return BroadcastResult(str(group), 'failed', 'Rejoined - send pending')
        except ChatAdminRequiredError:
            return BroadcastResult(str(group), 'failed', 'Admin required')
        except MessageTooLongError:
            return BroadcastResult(str(group), 'failed', 'Message too long')
        except Exception as e:
            error_str = str(e).lower()
            # Check for banned in general exceptions
            if "banned" in error_str or "forbidden" in error_str:
                try:
                    # Record ban in database
                    account_id = getattr(client, "_account_id", None)
                    if account_id:
                        group_id_str = str(entity.id) if hasattr(entity, "id") else str(group)
                        db.add_group_ban(account_id, group_id_str, group_name, error_str)
                    
                    from telethon.tl.functions.channels import LeaveChannelRequest
                    await client(LeaveChannelRequest(entity))
                    print(f"[BROADCASTER] Left banned group: {group}")
                    return BroadcastResult(str(group), "failed", "Banned - left group")
                except:
                    pass
            return BroadcastResult(str(group), "failed", str(e)[:80])
    async def _account_worker_task(self, worker, campaign, campaign_id, message_content, template_entities, db):
        """Run broadcasting for a single account."""
        results = {"sent": 0, "failed": 0, "account_id": worker.account_id, "phone": worker.phone}
        worker.status = "fetching_groups"
        from telethon import TelegramClient
        from telethon.sessions import StringSession
        import asyncio, re; from datetime import datetime, timedelta
        client = TelegramClient(StringSession(worker.session_string), self.API_ID, self.API_HASH)
        try:
            await client.connect()
            restriction = await self.check_spambot_restriction(client, worker.account_id)
            if restriction:
                db.update_account(worker.account_id, restricted_until=restriction.isoformat())
                worker.status = "restricted"; return results
            if not await client.is_user_authorized():
                worker.status = "session_expired"; return results
            groups = await self.get_all_dialogs(worker.session_string, client=client)
            if not groups:
                worker.status = "no_groups"; return results
            worker.groups = groups; worker.total_groups = len(groups)
            if campaign_id in self.campaign_progress: self.campaign_progress[campaign_id]["total"] += len(groups)
            log_bot_config = db.get_log_bot_by_client(campaign['client_id'])
            bot_token = log_bot_config['bot_token'] if log_bot_config and log_bot_config.get('is_active') else None
            target_id = log_bot_config['target_id'] if bot_token else None
            worker.status = "running"; cycle = 0
            while not self.stop_flags.get(campaign_id, False):
                cycle += 1
                if campaign_id in self.campaign_progress: self.campaign_progress[campaign_id]["cycle"] = max(self.campaign_progress[campaign_id].get("cycle", 1), cycle)
                for i, group in enumerate(groups):
                    if self.stop_flags.get(campaign_id, False): break
                    worker.current_group_index = i + 1; worker.current_group_name = group.get('name', 'Unknown')
                    try:
                        result = await self.send_to_group(client=client, group=group, message=message_content, formatting_entities=template_entities, message_type=campaign.get('send_mode', 'send'), forward_from_chat=campaign.get('forward_from_chat'), forward_message_id=campaign.get('forward_message_id'), forward_from_username=campaign.get('forward_from_username'), target_topic=campaign.get('target_topic'))
                        res_list = result if isinstance(result, list) else [result]
                        for res in res_list:
                            if res.status == 'sent':
                                results["sent"] += 1; worker.sent += 1; db.log_broadcast(campaign_id, worker.account_id, campaign['client_id'], res.group[:100], 'sent')
                                if bot_token and target_id:
                                    p_id = str(res.peer_id).replace('-100', '').replace('-', ''); message_link = f"https://t.me/c/{p_id}/{res.message_id}"
                                    asyncio.create_task(log_service.send_log(bot_token, target_id, res.group[:100], f"{worker.phone} | {worker.account.get('display_name', '')}", campaign.get('name', 'Campaign'), message_link))
                                delay = worker.calculate_delay(success=True)
                            elif res.status == 'flood_wait':
                                m = re.search(r'(\d+)', res.error or ''); wait_time = int(m.group(1)) if m else 60
                                delay = worker.calculate_delay(success=False, flood_wait=wait_time)
                            else:
                                results["failed"] += 1; worker.failed += 1; db.log_broadcast(campaign_id, worker.account_id, campaign['client_id'], res.group[:100], 'failed', res.error)
                                delay = worker.calculate_delay(success=False)
                            worker.add_log(res.group, res.status, res.error)
                        if not self.stop_flags.get(campaign_id, False): await asyncio.sleep(delay)
                    except Exception as e: print(f"[WORKER {worker.phone}] Inner error: {e}"); await asyncio.sleep(10)
                if not self.stop_flags.get(campaign_id, False): await asyncio.sleep(600)
            
            # Loop finished
            worker.status = "stopped"

        except Exception as e:
            print(f"[WORKER {worker.phone}] Fatal: {e}")
            worker.status = "crashed"
        finally:
            try: await client.disconnect()
            except: pass
            
        return results
    async def run_campaign_parallel(
        self,
        campaign_id: int,
        on_progress: Callable[[int, int, str], None] = None
    ) -> Dict[str, Any]:
        """
        Run campaign with ALL accounts broadcasting simultaneously.
        Each account sends to its OWN groups in parallel.
        """
        from database import db
        
        print(f"[BROADCASTER] Starting PARALLEL campaign {campaign_id}")
        
        # Initialize progress with per-account tracking
        self.campaign_progress[campaign_id] = {
            "sent": 0,
            "failed": 0,
            "total": 0,
            "current_group": "Initializing parallel workers...",
            "recent_logs": [],
            "status": "starting",
            "mode": "parallel",
            "cycle": 1,  # Track cycle count
            "accounts": {}  # account_id -> {status, sent, failed, current_group}
        }
        
        # Get campaign
        campaign = db.get_campaign_by_id(campaign_id)
        if not campaign:
            self.campaign_progress[campaign_id]["status"] = "error"
            return {"error": "Campaign not found"}
        
        # Load template if set
        template_entities = None
        template_id = campaign.get('template_id')
        if template_id:
            template = db.get_template_by_id(template_id)
            if template:
                json_entities = template.get('entities')
                if json_entities:
                    template_entities = convert_entities_to_telethon(json_entities)
                if template.get('text_content'):
                    campaign['message_content'] = template['text_content']
        
        message_content = campaign.get('message_content', '')
        
        # Debug: Log forward message settings
        send_mode = campaign.get('send_mode', 'send')
        forward_from_chat = campaign.get('forward_from_chat')
        forward_message_id = campaign.get('forward_message_id')
        print(f"[BROADCASTER] Campaign {campaign_id}: send_mode={send_mode}, forward_from_chat={forward_from_chat}, forward_message_id={forward_message_id}")
        print(f"[BROADCASTER] message_content length: {len(message_content) if message_content else 0}")
        
        # Get accounts - use campaign-specific accounts if set, otherwise all client accounts
        all_accounts = db.get_client_accounts(campaign['client_id'])
        if not all_accounts:
            self.campaign_progress[campaign_id]["status"] = "error"
            return {"error": "No accounts available"}
        
        # Filter to campaign-assigned accounts
        accounts = []
        
        # Check for multiple accounts (JSON array)
        import json
        account_ids_json = campaign.get('account_ids_json')
        if account_ids_json:
            try:
                account_ids = json.loads(account_ids_json)
                accounts = [a for a in all_accounts if a['id'] in account_ids]
            except:
                pass
        
        # Check for single account assignment
        if not accounts and campaign.get('account_id'):
            accounts = [a for a in all_accounts if a['id'] == campaign['account_id']]
        
        # If no specific accounts assigned, use all client accounts
        if not accounts:
            accounts = all_accounts
        
        active_accounts = [a for a in accounts if a.get('is_active', True)]
        if not active_accounts:
            self.campaign_progress[campaign_id]["status"] = "error"
            return {"error": "No active accounts"}
        
        print(f"[BROADCASTER] Launching {len(active_accounts)} parallel workers")
        
        # Create workers for each account
        workers: List[AccountWorker] = []
        for acc in active_accounts:
            worker = AccountWorker(acc, self.API_ID, self.API_HASH)
            workers.append(worker)
            
            # Initialize progress tracking for this account
            self.campaign_progress[campaign_id]["accounts"][acc['id']] = {
                "phone": acc.get('phone_number', 'Unknown'),
                "status": "starting",
                "sent": 0,
                "failed": 0,
                "total": 0,
                "current_group": None
            }
        
        # Initialize campaign state
        self.stop_flags[campaign_id] = False
        db.update_campaign_status(campaign_id, "running")
        self.campaign_progress[campaign_id]["status"] = "running"
        
        # Create background task to update progress
        async def update_progress():
            while not self.stop_flags.get(campaign_id, False):
                total_sent = sum(w.sent for w in workers)
                total_failed = sum(w.failed for w in workers)
                
                self.campaign_progress[campaign_id]["sent"] = total_sent
                self.campaign_progress[campaign_id]["failed"] = total_failed
                
                # Update per-account status
                for w in workers:
                    self.campaign_progress[campaign_id]["accounts"][w.account_id] = {
                        "phone": w.phone,
                        "status": w.get_status_display(),
                        "sent": w.sent,
                        "failed": w.failed,
                        "current_group": w.current_group_name,
                        "delay": round(w.current_delay, 1)
                    }
                
                # Aggregate recent logs from all workers
                all_logs = []
                for w in workers:
                    for log in w.recent_logs:
                        all_logs.append({**log, "account": w.phone[-4:]})
                all_logs.sort(key=lambda x: x.get('time', ''), reverse=True)
                self.campaign_progress[campaign_id]["recent_logs"] = all_logs[:30]
                
                await asyncio.sleep(2)
        
        # Start progress updater
        progress_task = asyncio.create_task(update_progress())
        
        # Launch all workers simultaneously (with concurrency limit)
        # Limit to 100 concurrent workers as requested
        concurrency_limit = asyncio.Semaphore(100)
        
        async def run_worker_with_limit(w):
            async with concurrency_limit:
                return await self._account_worker_task(w, campaign, campaign_id, message_content, template_entities, db)
        
        try:
            worker_tasks = [
                run_worker_with_limit(w)
                for w in workers
            ]
            
            results = await asyncio.gather(*worker_tasks, return_exceptions=True)
            
        except Exception as e:
            print(f"[BROADCASTER] Parallel execution error: {e}")
        finally:
            self.stop_flags[campaign_id] = True
            progress_task.cancel()
        
        # Aggregate results
        total_sent = sum(w.sent for w in workers)
        total_failed = sum(w.failed for w in workers)
        
        db.update_campaign_status(campaign_id, "stopped")
        self.campaign_progress[campaign_id]["status"] = "stopped"
        
        # Cleanup
        if campaign_id in self.stop_flags:
            del self.stop_flags[campaign_id]
        
        return {
            "sent": total_sent,
            "failed": total_failed,
            "accounts": len(workers),
            "mode": "parallel"
        }
    

    async def run_campaign(
        self, 
        campaign_id: int,
        on_progress: Callable[[int, int, str], None] = None
    ) -> Dict[str, Any]:
        """
        Run a complete campaign broadcast.
        
        Args:
            campaign_id: ID of the campaign to run
            on_progress: Optional callback for progress updates (sent, total, status)
        
        Returns:
            Dict with broadcast results and statistics
        """
        from database import db
        
        print(f"[BROADCASTER] Starting campaign {campaign_id}")
        
        # Initialize progress early so UI can see errors
        self.campaign_progress[campaign_id] = {
            "sent": 0,
            "failed": 0,
            "total": 0,
            "current_group": "Initializing...",
            "recent_logs": [],
            "status": "starting",
            "cycle": 1
        }
        
        # Get campaign details
        campaign = db.get_campaign_by_id(campaign_id)
        if not campaign:
            print(f"[BROADCASTER] Campaign {campaign_id} not found!")
            self.campaign_progress[campaign_id]["status"] = "error"
            self.campaign_progress[campaign_id]["current_group"] = "Error: Campaign not found"
            db.update_campaign_status(campaign_id, "failed")
            return {"error": "Campaign not found"}
        
        print(f"[BROADCASTER] Campaign: {campaign.get('name')}, client_id: {campaign.get('client_id')}")
        
        # Load message template if set (for premium emojis/formatting)
        template_entities = None
        template_id = campaign.get('template_id')
        if template_id:
            template = db.get_template_by_id(template_id)
            if template:
                print(f"[BROADCASTER] Using template: {template.get('name')} with entities")
                # Convert JSON entities to Telethon format for premium emoji support
                json_entities = template.get('entities')
                if json_entities:
                    template_entities = convert_entities_to_telethon(json_entities)
                    print(f"[BROADCASTER] Converted {len(json_entities)} entities to Telethon format")
                # Also update message content from template if needed
                if template.get('text_content'):
                    campaign['message_content'] = template['text_content']
            else:
                print(f"[BROADCASTER] Template {template_id} not found, using plain message")
        
        # Get accounts for this client
        accounts = db.get_client_accounts(campaign['client_id'])
        print(f"[BROADCASTER] Found {len(accounts) if accounts else 0} accounts for client")
        if not accounts:
            print(f"[BROADCASTER] No accounts available!")
            self.campaign_progress[campaign_id]["status"] = "error"
            self.campaign_progress[campaign_id]["current_group"] = "Error: No accounts assigned"
            db.update_campaign_status(campaign_id, "failed")
            return {"error": "No accounts available"}
        
        # Filter active accounts
        active_accounts = [a for a in accounts if a.get('is_active', True)]
        print(f"[BROADCASTER] Active accounts: {len(active_accounts)}")
        if not active_accounts:
            print(f"[BROADCASTER] No active accounts!")
            self.campaign_progress[campaign_id]["status"] = "error"
            self.campaign_progress[campaign_id]["current_group"] = "Error: No active accounts"
            db.update_campaign_status(campaign_id, "failed")
            return {"error": "No active accounts"}
        
        # Determine which account to use
        selected_account_id = campaign.get('account_id')
        if selected_account_id:
            # Use specifically selected account
            selected_account = next((a for a in active_accounts if a['id'] == selected_account_id), None)
            if not selected_account:
                print(f"[BROADCASTER] Selected account {selected_account_id} not found in active accounts")
                self.campaign_progress[campaign_id]["status"] = "error"
                self.campaign_progress[campaign_id]["current_group"] = f"Error: Selected account not found or inactive"
                db.update_campaign_status(campaign_id, "failed")
                return {"error": "Selected account not found or inactive"}
            broadcast_account = selected_account
            print(f"[BROADCASTER] Using SELECTED account: {broadcast_account.get('phone_number')}")
        else:
            # Use first account (default behavior)
            broadcast_account = active_accounts[0]
            print(f"[BROADCASTER] Using FIRST account: {broadcast_account.get('phone_number')}")
        
        # Determine target groups
        send_mode = campaign.get('send_mode', 'send')
        broadcast_all = True  # Default to broadcast_all
        
        # Check if we should use database groups or fetch from account
        db_groups = db.get_campaign_groups(campaign_id)
        print(f"[BROADCASTER] DB groups: {len(db_groups) if db_groups else 0}")
        
        if db_groups:
            # Use groups from database
            groups = [{"id": g.get('group_username'), "name": g.get('group_username')} for g in db_groups]
        else:
            # Broadcast to all dialogs from the selected account
            self.campaign_progress[campaign_id]["current_group"] = f"Fetching groups from {broadcast_account.get('phone_number')}..."
            print(f"[BROADCASTER] Fetching dialogs from account: {broadcast_account.get('phone_number')}")
            
            try:
                groups = await self.get_all_dialogs(broadcast_account.get('session_string'))
            except Exception as e:
                print(f"[BROADCASTER] Error fetching dialogs: {e}")
                self.campaign_progress[campaign_id]["status"] = "error"
                self.campaign_progress[campaign_id]["current_group"] = f"Error: Failed to connect - {str(e)[:50]}"
                db.update_campaign_status(campaign_id, "failed")
                return {"error": f"Failed to fetch dialogs: {e}"}
            
            print(f"[BROADCASTER] Got {len(groups) if groups else 0} groups from account")
            if not groups:
                print(f"[BROADCASTER] No groups found on account!")
                self.campaign_progress[campaign_id]["status"] = "error"
                self.campaign_progress[campaign_id]["current_group"] = "Error: Account has no joined groups"
                db.update_campaign_status(campaign_id, "failed")
                return {"error": "No groups found on account"}
        
        # Get forward settings
        forward_from_chat = campaign.get('forward_from_chat')
        forward_message_id = campaign.get('forward_message_id')
        forward_from_username = campaign.get('forward_from_username')
        
        # Initialize campaign state
        self.stop_flags[campaign_id] = False
        results = {
            "sent": 0,
            "failed": 0,
            "skipped": 0,
            "flood_waits": 0,
            "total_wait_time": 0,
            "details": []
        }
        
        # Update campaign status
        db.update_campaign_status(campaign_id, "running")
        
        # =============================================
        # SMART ANTI-SPAM RATE LIMITING SYSTEM
        # =============================================
        # Based on Telegram's known limits and best practices:
        # - ~30 msgs/sec bulk limit (we use much slower for safety)
        # - Exponential backoff on errors
        # - Account rotation on failures
        # - Variable delays to appear human-like
        # - Rest periods after batches
        
        # Base settings - SAFE values that won't trigger bans
        BASE_DELAY = 25  # 25 seconds base - safe window
        MIN_DELAY = 15   # Never go below 15s
        MAX_DELAY = 120  # Cap at 2 minutes
        
        # Jitter - makes timing look human (Â±30%)
        JITTER_PERCENT = 0.30
        
        # Batch rest - longer pause every N messages
        BATCH_SIZE = random.randint(8, 12)  # Randomize batch size
        BATCH_REST_MIN = 60   # 1 minute minimum rest
        BATCH_REST_MAX = 180  # 3 minutes maximum rest
        
        # Cycle pause (between full loops)
        CYCLE_PAUSE = random.randint(480, 720)  # 8-12 minutes
        
        # Account health tracking
        account_failures = {}  # account_id -> consecutive_failures
        MAX_FAILURES_BEFORE_ROTATE = 3
        
        # Current delay (adaptive)
        current_delay = BASE_DELAY
        success_streak = 0
        failure_streak = 0
        batch_count = 0
        account_index = 0
        messages_this_hour = 0
        hour_start = datetime.now()
        
        # Process groups
        total = len(groups)
        cycle_count = 0
        
        # Initialize live progress
        self.campaign_progress[campaign_id] = {
            "sent": 0,
            "failed": 0,
            "total": total,
            "current_group": None,
            "current_index": 0,
            "recent_logs": [],
            "status": "running",
            "cycle": 1,
            "delay": current_delay
        }
        
        # Continuous cycling loop - runs until stopped
        while not self.stop_flags.get(campaign_id, False):
            cycle_count += 1
            self.campaign_progress[campaign_id]["cycle"] = cycle_count
            self.campaign_progress[campaign_id]["current_index"] = 0
            
            for i, group_data in enumerate(groups):
                # Check stop flag
                if self.stop_flags.get(campaign_id, False):
                    break
                
                # Get group info (can be dict from dialogs or string)
                if isinstance(group_data, dict):
                    group = group_data
                else:
                    group = group_data
                
                # Choose account: use selected account if specified, else rotate
                if selected_account_id:
                    # Use only the selected account
                    account = broadcast_account
                else:
                    # Rotate through all active accounts
                    account = active_accounts[account_index % len(active_accounts)]
                session_string = account.get('session_string')
                
                if not session_string:
                    account_index += 1
                    continue
                
                # Update progress - sending to this group
                group_name = group.get('name', str(group)) if isinstance(group, dict) else str(group)
                self.campaign_progress[campaign_id]["current_group"] = group_name
                self.campaign_progress[campaign_id]["current_index"] = i + 1
                
                # Connect client
                try:
                    client = TelegramClient(
                        StringSession(session_string),
                        self.API_ID,
                        self.API_HASH
                    )
                    await client.connect()
                    should_disconnect = True
                    # client._account_id = worker.account_id  # Tracking for ban checks (worker not defined here)
                    
                    if not await client.is_user_authorized():
                        account_index += 1
                        results["skipped"] += 1
                        await client.disconnect()
                        continue
                    
                    # Send or forward message
                    result = await self.send_to_group(
                        client,
                        group,
                        campaign.get('message_content', ''),
                        campaign.get('media_file_id'),
                        message_type=send_mode,
                        forward_from_chat=forward_from_chat,
                        forward_message_id=forward_message_id,
                        forward_from_username=forward_from_username,
                        formatting_entities=template_entities
                    )
                    
                    await client.disconnect()
                    
                    # Process result(s) - forums return a list, regular groups return single result
                    result_list = result if isinstance(result, list) else [result]
                    
                    for res in result_list:
                        if res.status == 'sent':
                            results["sent"] += 1
                            
                            # Log broadcast
                            db.log_broadcast(
                                campaign_id=campaign_id,
                                account_id=account['id'],
                                client_id=campaign['client_id'],
                                group_name=res.group[:100],  # Use actual topic name
                                status='sent'
                            )
                            
                            # Track success streak
                            success_streak += 1
                            failure_streak = 0
                            
                        elif res.status == 'flood_wait':
                            results["flood_waits"] += 1
                            
                            # Extract wait time
                            wait_match = re.search(r'(\d+)', res.error or '')
                            wait_time = int(wait_match.group(1)) if wait_match else 60
                            results["total_wait_time"] += wait_time
                            
                            # Format wait time for display
                            if wait_time >= 3600:
                                wait_display = f"{wait_time // 3600}h {(wait_time % 3600) // 60}m"
                            elif wait_time >= 60:
                                wait_display = f"{wait_time // 60}m {wait_time % 60}s"
                            else:
                                wait_display = f"{wait_time}s"
                            
                            # SMART FLOOD HANDLING:
                            # If wait > 5 min, SKIP this group and rotate account
                            # Don't block the entire campaign for hours!
                            if wait_time > 300:  # More than 5 minutes
                                print(f"[BROADCASTER] FloodWait {wait_display} - SKIPPING group, rotating account")
                                self.campaign_progress[campaign_id]["status"] = f"flood_skip ({wait_display})"
                                # Mark this group as failed due to flood
                                db.log_broadcast(
                                    campaign_id=campaign_id,
                                    account_id=account['id'],
                                    client_id=campaign['client_id'],
                                    group_name=res.group[:100],
                                    status='failed',
                                    error_message=f"FloodWait {wait_display} - skipped"
                                )
                                results["failed"] += 1
                                # Rotate to next account immediately
                                account_index += 1
                                await asyncio.sleep(5)  # Brief pause before continuing
                            else:
                                # Short wait - we can wait it out
                                self.campaign_progress[campaign_id]["status"] = f"flood_wait ({wait_display})"
                                await asyncio.sleep(wait_time + random.randint(5, 15))
                            
                            self.campaign_progress[campaign_id]["status"] = "running"
                            
                            # Rotate to next account
                            account_index += 1
                            
                        else:
                            results["failed"] += 1
                            db.log_broadcast(
                                campaign_id=campaign_id,
                                account_id=account['id'],
                                client_id=campaign['client_id'],
                                group_name=res.group[:100],
                                status='failed',
                                error_message=res.error
                            )
                            failure_streak += 1
                            success_streak = 0
                        
                        # Add to recent logs (keep last 30 for forums)
                        log_entry = {
                            "group": res.group[:40],
                            "status": res.status,
                            "error": res.error[:30] if res.error else None,
                            "index": i + 1,
                            "cycle": cycle_count
                        }
                        self.campaign_progress[campaign_id]["recent_logs"].append(log_entry)
                        if len(self.campaign_progress[campaign_id]["recent_logs"]) > 30:
                            self.campaign_progress[campaign_id]["recent_logs"].pop(0)
                    
                    # Update live progress after processing all results
                    self.campaign_progress[campaign_id]["sent"] = results["sent"]
                    self.campaign_progress[campaign_id]["failed"] = results["failed"]
                    
                    # Progress callback
                    if on_progress:
                        on_progress(i + 1, total, result_list[-1].status if result_list else 'unknown')
                    
                    # =============================================
                    # SMART DELAY CALCULATION
                    # =============================================
                    
                    if result.status == 'sent':
                        success_streak += 1
                        failure_streak = 0
                        batch_count += 1
                        messages_this_hour += 1
                        
                        # SUCCESS: Gradually decrease delay (reward good behavior)
                        if success_streak >= 5:
                            current_delay = max(MIN_DELAY, current_delay * 0.95)  # 5% faster
                        
                        # Reset account failure count
                        account_failures[account['id']] = 0
                        
                    elif result.status == 'flood_wait':
                        success_streak = 0
                        failure_streak += 1
                        
                        # FLOOD: Exponential backoff
                        current_delay = min(MAX_DELAY, current_delay * 2.0)
                        
                        # Track account issues
                        account_failures[account['id']] = account_failures.get(account['id'], 0) + 1
                        
                        # Rotate account if too many failures
                        if account_failures[account['id']] >= MAX_FAILURES_BEFORE_ROTATE:
                            account_index += 1
                            
                    else:  # Failed
                        success_streak = 0
                        failure_streak += 1
                        
                        # FAILED: Increase delay slightly
                        current_delay = min(MAX_DELAY, current_delay * 1.25)
                        
                        # Track failures
                        account_failures[account['id']] = account_failures.get(account['id'], 0) + 1
                    
                    # Check hourly limit - rotate account every ~50 messages
                    if messages_this_hour >= 50:
                        # Check if hour has passed
                        if (datetime.now() - hour_start).seconds < 3600:
                            # Still within the hour, rotate account
                            account_index += 1
                            messages_this_hour = 0
                        else:
                            # New hour started
                            hour_start = datetime.now()
                            messages_this_hour = 0
                    
                    # Update progress with current delay
                    self.campaign_progress[campaign_id]["delay"] = round(current_delay, 1)
                    
                    # Apply delay (only if not stopping and more groups)
                    if not self.stop_flags.get(campaign_id, False) and i < total - 1:
                        # Check if batch rest needed
                        if batch_count >= BATCH_SIZE:
                            batch_count = 0
                            BATCH_SIZE = random.randint(8, 12)  # Randomize for next batch
                            rest_time = random.randint(BATCH_REST_MIN, BATCH_REST_MAX)
                            self.campaign_progress[campaign_id]["status"] = f"batch_rest_{rest_time}s"
                            await asyncio.sleep(rest_time)
                            self.campaign_progress[campaign_id]["status"] = "running"
                        else:
                            # Apply jitter to delay (Â±30%)
                            jitter = current_delay * JITTER_PERCENT
                            actual_delay = current_delay + random.uniform(-jitter, jitter)
                            actual_delay = max(MIN_DELAY, actual_delay)  # Never below minimum
                            await asyncio.sleep(actual_delay)
                        
                except Exception as e:
                    results["failed"] += 1
                    failure_streak += 1
                    current_delay = min(MAX_DELAY, current_delay * 1.5)
                    results["details"].append({
                        "group": group_name if 'group_name' in dir() else str(group),
                        "status": "failed",
                        "error": str(e)[:80]
                    })
            
            # Cycle completed - check if should continue
            if self.stop_flags.get(campaign_id, False):
                break
            
            # Update analytics after each cycle
            db.update_analytics(
                client_id=campaign['client_id'],
                broadcasts=results["sent"] + results["failed"],
                success=results["sent"],
                failed=results["failed"]
            )
            
            # Cycle pause with randomized duration (10-15 minutes)
            CYCLE_PAUSE = random.randint(600, 900)
            self.campaign_progress[campaign_id]["status"] = "cycle_pause"
            self.campaign_progress[campaign_id]["current_group"] = f"Cycle {cycle_count} done. Next in {CYCLE_PAUSE//60}m..."
            
            # Wait in chunks so we can check stop flag
            for _ in range(CYCLE_PAUSE // 10):
                if self.stop_flags.get(campaign_id, False):
                    break
                await asyncio.sleep(10)
            
            # Reset delay for new cycle
            current_delay = BASE_DELAY
            success_streak = 0
            
            if not self.stop_flags.get(campaign_id, False):
                self.campaign_progress[campaign_id]["status"] = "running"
        
        # Campaign stopped
        db.update_campaign_status(campaign_id, "stopped")
        
        if campaign_id in self.campaign_progress:
            self.campaign_progress[campaign_id]["status"] = "stopped"
        
        # Cleanup
        if campaign_id in self.stop_flags:
            del self.stop_flags[campaign_id]
        
        return results
    
    def stop_campaign(self, campaign_id: int):
        """Signal a running campaign to stop."""
        self.stop_flags[campaign_id] = True
    
    async def start_campaign_async(self, campaign_id: int, parallel: bool = True) -> asyncio.Task:
        """
        Start a campaign as a background task.
        
        Args:
            campaign_id: ID of the campaign to run
            parallel: If True (default), run all accounts simultaneously.
                     If False, use sequential rotation mode.
        """
        if parallel:
            task = asyncio.create_task(self.run_campaign_parallel(campaign_id))
        else:
            task = asyncio.create_task(self.run_campaign(campaign_id))
        self.running_campaigns[campaign_id] = task
        return task
    
    def is_campaign_running(self, campaign_id: int) -> bool:
        """Check if a campaign is currently running."""
        task = self.running_campaigns.get(campaign_id)
        return task is not None and not task.done()

    async def resume_campaigns(self):
        """Resume all campaigns that were 'running' or 'starting'."""
        print("[BROADCASTER] Checking for interrupted campaigns...")
        try:
            # Query directly from DB
            campaigns = self.db.get_all_campaigns()
            count = 0
            for campaign in campaigns:
                if campaign.get('status') in ['running', 'starting']:
                    campaign_id = campaign['id']
                    # Verify it's not already running (unlikely on fresh start)
                    if not self.is_campaign_running(campaign_id):
                        print(f"[BROADCASTER] Resuming campaign {campaign_id}: {campaign.get('name')}")
                        # Update status to 'starting' just in case
                        self.db.update_campaign_status(campaign_id, 'starting')
                        # Start async
                        await self.start_campaign_async(campaign_id)
                        count += 1
            
            if count > 0:
                print(f"[BROADCASTER] Resumed {count} campaigns")
            else:
                print("[BROADCASTER] No interrupted campaigns found")
                
        except Exception as e:
            print(f"[BROADCASTER] Error resuming campaigns: {e}")


# Global broadcaster instance
broadcaster = None

def get_broadcaster(db):
    """Get or create broadcaster instance."""
    global broadcaster
    if broadcaster is None:
        broadcaster = Broadcaster(db)
    return broadcaster
